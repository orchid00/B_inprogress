---
title: What is Bioconductor?
description: >-
  In this chapter you will get hands-on with Bioconductor. Bioconductor is the specialized 
  repository for bioinformatics software, developed and manintained by the R community. You
  will learn how to install and use packages, for various kinds of analyses. You will be 
  introduced to S4 objects and functions, as most packages within Bioconductor inherit from S4.
  Lastly, we are going to use a real genomic dataset to explore biological data using Bioconductor packages. 
---

## Introduction to the Bioconductor Project

```yaml
type: VideoExercise
lang: r
xp: 50
skills: 1
key: 8445cb19c9
```

In this video a short intro of Bioconductor project will be given. You
will learn about the basic analyses that you are able to perform using
the Bioconductor project. Also, a short intro on how to install and
use packages for various kinds of analyses. As example, we will use the
BSgenome package to start the exploring genomic dataset bit by bit.

`@video_link`

//player.vimeo.com/video/154783078

`@video_hls`

//videos.datacamp.com/transcoded/000_placeholders/v1/hls-temp.master.m3u8
---

## BiocInstaller

```yaml
type:  NormalExercise
lang: r
xp: 50
skills: 1
key: 8a75737abd
```

If you check any Bioconductor package page, you will find out that every installation 
requires the script biocLite.R. If you don't have the BiocInstaller package installed,
you can install and load it at the same time using this call:

    source("https://bioconductor.org/biocLite.R") 
    
We had already installed an loaded the ‘BiocInstaller’ package for you. Notice that you 
don't need to call `library()` to load it. To check which are the loaded packages use:

    search()

Because Bioconductor is in constant development we are better off documenting the version 
that we are currently using. You can check the version of Bioconductor using:          

    BiocInstaller::biocVersion()
         
 or, if BioCInstaller is already loaded (like on this exercise) you can type directly 
 
    biocVersion()
    
`@instructions`

Your task is to check both options in the console, and find out the version of biocInstaller.

`@hint`

Test each line of code from the text, one at the time.

`@pre_exercise_code`

```{r}

```

`@sct`

```{r}

# the long version to check the version of BiocInstaller



# The sort version to check the version of BiocInstaller


```
---

## BiocLite to load packages

```yaml
type: NormalExercise
lang: r
xp: 100
skills: 1
key: 58d4130bd8
```

If you would like to research full genomes, or part of a genome and its characteristics,
The package BSgenome comes in handy.

We have installed it for you, using 

          source("https://bioconductor.org/biocLite.R")
          biocLite("BSgenome")

Any bioconductor package can be installed this way, and then it needs to be loaded using library().
like packages from CRAN.

`@instructions`

          Now it is your turn to load the package see required packages and check the version of BSgenome
          
`@hint`

check out 
?library - to load
?packageVersion to check the version

`@pre_exercise_code`

```{r}
# we have installed the package BSgenome for you
```

`@sample_code`

```{r}
# First, load the package

# Read the lines that start with Loading required package: 
# Are there many packages?
# no code needed here

# Finally, check the version of the package

```

`@solution`

```{r}

# First, load the package
library(BSgenome)

# Read the lines that start wit Loading required package: 
# Are there many packages?
# no code neded here

# Finally, check the version of the package
packageVersion("BSgenome")

```

`@sct`

```{r}

```
---

## The role of S4 in Bioconductor

```yaml
type: VideoExercise
lang: r
xp: 50
skills: 1
key: 
```

S4 is a formal object-oriented programming (OOP) system. You will be
introduced to the benefits of using S4 and inheritance. A short
description about the framwork of S4 components (class, function and
methods). Later, you will be shown how to initialize and set arguments.

`@video_link`

//player.vimeo.com/video/154783078

`@video_hls`

//videos.datacamp.com/transcoded/000_placeholders/v1/hls-temp.master.m3u8
---

## Interaction with clasess

```yaml
type: NormalExercise
lang: r
xp: 100
skills: 1
key: 
```
Let's say we have an object called genome1, this is an object of class BSgenome. You can check with 

          class(genome1)
      
To investigate the possibilities of S4 objects, we can ask if this object is S4

          isS4(genome1)

The answer is TRUE

S4 formally defines the representation and inheritance for each class, so we can check that too

          isClass(genome1)
       
The answer is TRUE
          
          getClass(genome1)
                    
@instructions`

  Use the function getClass to find out more information about the BSgenome that we have loaded for you.
        
`@hint`

check out 
?getClass

`@pre_exercise_code`

```{r}
# we have installed the package BSgenome for you
# and saved an R object called genome1
```

`@sample_code`

```{r}
# Find out more about genome1

```

`@solution`

```{r}
# Find out more about genome1
getClass(genome1)

```

`@sct`

```{r}

```
---
## Introducing biology of genomic datasets

```yaml
type: VideoExercise
lang: r
xp: 50
skills: 1
key: 
```

What is a genome?
How is the genome information stored?
We are going to explore a public genome repository, using the BSgenome package.
The selected genome is the yeast genome, also called *S. Cerevisiae*

`@video_link`

//player.vimeo.com/video/154783078

`@video_hls`

//videos.datacamp.com/transcoded/000_placeholders/v1/hls-temp.master.m3u8
---

## Accessors - accessing functionality of an object

```yaml
type: NormalExercise
lang: r
xp: 50
skills: 1
key: 
```   

Since we are working with objects, these objects have characteristics that we might find useful 
to explore. We can access these characteristics/ features / functionalities or however you want
to call it using **accessors**.

The object genome1 is a BSgenome object, which is linked to the GenomeDescription class and object.
Thanks to this, all the accessor methods for GenomeDescription objects can be used on
any BSgenome object. To see a list of the accessor methods, find more information here:  
https://www.rdocumentation.org/packages/GenomeInfoDb/versions/1.8.3/topics/GenomeDescription-class

For example, we are working with the yeat genome and we can ask the accessor organism.
Which genome is in use? Note this will give you the latin name of the organism

         organism(genome1)

To see the names of the sequences of genome1 we can use the accesor getnames()


         seqnames(genome1)

Once we know the sequence names, we can also select the start and end positions of a sequence. 
This helps us to filter sequences. Or in other words, to retrieve sequence information from one 
section of a chromosome. Here we will select chromosome I from positon 100 up to position 150.

`@sample_code`

```{r}
getSeq(genome1, "chrI", 100, 150)
```     
For more information read ?getSeq (from the BSgenome package).

@instructions`

Use the function getSeq to find the first 20 bases of each chromosome
        
`@hint`

- you only need to specify the end of the sequence
- If ‘names’ is missing, then ‘seqnames(x)’ is used.
- start of the sequence will start from 1 as default
- to see the last part of any vector you can use the negative notation
(minus) here this filter should be provided in the start

`@pre_exercise_code`

```{r}
# Get the first 20 bases of each chromosome

# Get the last 20 bases of each chromosome

```

`@sample_code`

```{r}
# Find out more about genome1

```

`@solution`

```{r}
# Get the first 20 bases of each chromosome
getSeq(genome1, end = 20)

# Get the last 20 bases of each chromosome
getSeq(genome1, start = -20)

```

`@sct`

```{r}

```
---

##  Other genomes

```yaml
type: MultipleChoice
lang: r
xp: 50
skills: 1
key: 
```  
The BSgenome package provides support for various genomes. Bioconductor 
has saved each genome as a different package that inherits from BSgenome.
If you want to explore the available BSgenome data packages check:

          available.genomes()

You will see that there are many. Each of these data packages contains the genome information
of an organism, and sometimes different versions. Because some genomes are usually big (Genomics 
and big data are two related topics). We will keep using the S. cervisiae genome because of its
small genome size. We loaded it again using the following code:

         yeaStGenome <- getBSgenome( "BSgenome.Scerevisiae.UCSC.sacCer3")

We can explore this using seqinfo(), seqnames() or seqlengths() common accessors

          seqnames(yeastGenome)
          seqinfo(yeastGenome)
          seqlengths(yeastGenome)

We can also have a look at each chromosome by name

          yeastGenome$chrI
          

`@instructions`

Using one of the mentioned functions check which chromosome of the yeastGenome is the shortest one

`@hint`

check out 
?seqinfo
?seqlengths
?sort
?order

`@solution`

```{r}
sort(seqlengths(yeastGenome))
```
---

## Letter frequency

```yaml
type: NormalExercise
lang: r
xp: 100
skills: 1
key: 
```

There is a useful function called letterFrequency which we can use in
a sequence to find out information about frequency.
How would you check the frequency of CG in chromosome I?

          letterFrequency(yeastGenome$chrI, "CG") 

That will give you the counts. If you wanted to see the percentage
instead, you need to use the attribute as.prob = TRUE. For more information
always check ?letterFrequency

`@instructions`

      What is the percentage og CG frequency in chrmI ?
          
`@hint`

To check if you are correct before submitting the answer should be
about 39%

check ?letterFrequency is you still have doubts
          
`@solution`

```{r}
          letterFrequency(yeastGenome$chrI, "CG", as.prob = TRUE)
```
      - type: MultipleChoiceExercise
        title: bsapply from BSgenome
        content: >
          Let's now investigate the function bsapply from the BSgenome package.
          This is a function similar to apply which helps you iterate to each
          chromosome in a genome.


          In the following example, we are iterating through each chromosome of
          the yeastGenome to count the frequency of CG


          param <- new("BSParams", X = yeastGenome, FUN = letterFrequency,
          simplify = TRUE)

          bsapply(param, letters = "GC")


          Note how the mitochondria chromosome is very different. 


          Q:  is this showing you the counts or percentages of letterFrequency
          for each chromosome?

          @solution

          Answer:

          counts
